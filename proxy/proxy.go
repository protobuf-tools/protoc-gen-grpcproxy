// SPDX-FileCopyrightText: Copyright 2022 The protobuf-tools Authors
// SPDX-License-Identifier: BSD-3-Clause

// Package proxy generates RPC service proxy.
package proxy

import (
	"fmt"
	"path"
	"path/filepath"
	"sort"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
)

var version = "devel"

// list of _proxy.pb.go files package dependencies.
const (
	contextPackage = protogen.GoImportPath("context")
	errorsPackage  = protogen.GoImportPath("errors")
	netPackage     = protogen.GoImportPath("net")

	emptyPackage = protogen.GoImportPath("google.golang.org/protobuf/types/known/emptypb")
	grpcPackage  = protogen.GoImportPath("google.golang.org/grpc")
)

var pbPackage protogen.GoImportPath

// Config represents a protoc-gen-proxy config.
type Config struct {
	Standalone bool
}

// Method represents a generated RPC method.
type Method struct {
	GoName      string
	IsStreaming bool
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// GenerateFile generates RPC service proxy from .pb.go types.
func GenerateFile(p *protogen.Plugin, f *protogen.File, cfg *Config) *protogen.GeneratedFile {
	if len(f.Services) == 0 {
		return nil
	}

	filename := f.GeneratedFilenamePrefix + "_proxy.pb.go"
	goImportPath := f.GoImportPath
	if cfg.Standalone {
		goImportPath = protogen.GoImportPath(".") // dummy path for import pb package
	}

	g := p.NewGeneratedFile(filename, goImportPath)
	g.QualifiedGoIdent(contextPackage.Ident("Context"))
	g.QualifiedGoIdent(errorsPackage.Ident("New"))
	g.QualifiedGoIdent(netPackage.Ident("Addr"))
	g.QualifiedGoIdent(grpcPackage.Ident("CallOption"))

	goPackageName := f.GoPackageName
	if cfg.Standalone {
		pbPackage = f.GoImportPath
		g.QualifiedGoIdent(pbPackage.Ident(""))
		goPackageName += "proxy"
	}

	g.P("// Code generated by protoc-gen-proxy. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-proxy ", version)
	g.P("// - protoc           ", protocVersion(p))
	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
	g.P(`package `, goPackageName)
	g.P()
	g.P(`const (`)

	services := f.Services
	for i, service := range services {
		sort.Slice(services[i].Methods, func(j, k int) bool { return services[i].Methods[j].GoName < services[i].Methods[k].GoName })

		for _, method := range service.Methods {
			g.P(`	FullMethod`, method.GoName, ` = `, strconv.Quote(path.Join("/"+string(service.Desc.FullName()), string(method.Desc.Name()))))
		}
		g.P(`)`)

		serviceName := service.GoName
		methods := make(map[Method]string)
		idStr := pbPackage.String()
		importPath := filepath.Base(idStr[1 : len(idStr)-1])
		registerServerName := fmt.Sprintf("Register%sServer", serviceName)
		if cfg.Standalone {
			registerServerName = importPath + "." + registerServerName
		}

		for _, method := range service.Methods {
			mes := Method{
				GoName:      method.GoName,
				IsStreaming: method.Desc.IsStreamingServer(),
			}

			input := method.Input.GoIdent.GoName
			output := method.Output.GoIdent.GoName
			if input == "Empty" || output == "Empty" {
				g.QualifiedGoIdent(emptyPackage.Ident("Empty"))
			}
			if cfg.Standalone {
				// handle emptypb
				if input != "Empty" {
					input = importPath + "." + input
				}
				if output != "Empty" {
					output = importPath + "." + output
				}
			}

			// handle emptypb
			if input == "Empty" {
				input = "emptypb.Empty"
			}
			if output == "Empty" {
				output = "emptypb.Empty"
			}

			args := fmt.Sprintf(`(ctx context.Context, req *%s) (*%s, error)`, input, output)
			if cfg.Standalone && mes.IsStreaming {
				args = fmt.Sprintf(`(req *%s, srv %s_%sServer) error`, input, importPath+"."+serviceName, method.GoName)
			}
			methods[mes] = args
		}

		// sort RPC methods
		sortMethods := make([]Method, len(methods))
		i := 0
		for mes := range methods {
			sortMethods[i] = mes
			i++
		}
		sort.Slice(sortMethods, func(i, j int) bool { return sortMethods[i].GoName < sortMethods[j].GoName })

		serverName := "proxyServer"
		g.P(`var ErrNotSupported = errors.New("operation not supported")`)
		g.P()
		g.P(`type `, serverName, ` struct {`)
		g.P(`	proxy *Proxy`)
		g.P(`}`)
		g.P()
		for _, mes := range sortMethods {
			args := methods[mes]

			ret := `fn(ctx, req)`
			retErr := `nil, ErrNotSupported`
			if mes.IsStreaming {
				ret = `fn(req, srv)`
				retErr = `ErrNotSupported`
			}
			g.P(`func (s *`, serverName, `) `, mes.GoName, args, ` {`)
			g.P(`	fn := s.proxy.`, mes.GoName)
			g.P(` 	if fn == nil {`)
			g.P(` 		return `, retErr)
			g.P(` 	}`)
			g.P()
			g.P(`return `, ret)
			g.P(`}`)
			g.P()
		}
		g.P()
		g.P(`// Proxy allows to create `, serviceName, ` proxy servers.`)
		g.P(`type Proxy struct {`)
		for _, mes := range sortMethods {
			args := methods[mes]
			g.P(`	`, mes.GoName, ` func`, args)
		}
		g.P(`}`)
		g.P()
		g.P(`// Serve starts serving the proxy server on the given listener with the specified options.`)
		g.P(`func (p *Proxy) Serve(l net.Listener, opts ...grpc.ServerOption) error {`)
		g.P(`	srv := grpc.NewServer(opts...)`)
		g.P(`	`, registerServerName, `(srv, &`, serverName, `{proxy: p})`)
		g.P()
		g.P(`	return srv.Serve(l)`)
		g.P(`}`)
	}

	return g
}
